package app

import (
	"fmt"
	"log"
	"sync"
	"time"

	"OwlWhisper/internal/core"
	"OwlWhisper/internal/protocol"
	"OwlWhisper/internal/storage"

	"github.com/google/uuid"
	"github.com/libp2p/go-libp2p/core/peer"
	"google.golang.org/protobuf/proto"
)

// ChatService —É–ø—Ä–∞–≤–ª—è–µ—Ç –ª–æ–≥–∏–∫–æ–π —á–∞—Ç–∞, —Å–≤—è–∑—ã–≤–∞—è —Å–µ—Ç–µ–≤–æ–π —Å–ª–æ–π —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º
type ChatService struct {
	coreController    core.ICoreController
	messageRepository storage.IMessageRepository
	contactRepository storage.IContactRepository

	// –ö–∞–Ω–∞–ª—ã –¥–ª—è UI –∫–ª–∏–µ–Ω—Ç–æ–≤
	messagesChan chan ChatMessage
	peersChan    chan []peer.ID

	// –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∫–∞–Ω–∞–ª—ã
	stopChan chan struct{}

	// –°–æ—Å—Ç–æ—è–Ω–∏–µ
	isRunning bool
	mutex     sync.RWMutex
}

// ChatMessage –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è UI –∫–ª–∏–µ–Ω—Ç–æ–≤
type ChatMessage struct {
	ID          string    `json:"id"`
	Text        string    `json:"text"`
	SenderID    string    `json:"sender_id"`
	SenderName  string    `json:"sender_name"`
	Timestamp   time.Time `json:"timestamp"`
	ChatType    string    `json:"chat_type"`
	RecipientID string    `json:"recipient_id"`
	IsOutgoing  bool      `json:"is_outgoing"`
}

// NewChatService —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å —á–∞—Ç–∞
func NewChatService(
	coreController core.ICoreController,
	messageRepository storage.IMessageRepository,
	contactRepository storage.IContactRepository,
) *ChatService {
	return &ChatService{
		coreController:    coreController,
		messageRepository: messageRepository,
		contactRepository: contactRepository,
		messagesChan:      make(chan ChatMessage, 100),
		peersChan:         make(chan []peer.ID, 10),
		stopChan:          make(chan struct{}),
	}
}

// Start –∑–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Ä–≤–∏—Å —á–∞—Ç–∞
func (cs *ChatService) Start() error {
	cs.mutex.Lock()
	defer cs.mutex.Unlock()

	if cs.isRunning {
		return fmt.Errorf("—Å–µ—Ä–≤–∏—Å —á–∞—Ç–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω")
	}

	cs.isRunning = true
	log.Println("üöÄ ChatService –∑–∞–ø—É—â–µ–Ω")

	// –ó–∞–ø—É—Å–∫–∞–µ–º –≥–æ—Ä—É—Ç–∏–Ω—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
	go cs.handleIncomingMessages()

	// –ó–∞–ø—É—Å–∫–∞–µ–º –≥–æ—Ä—É—Ç–∏–Ω—É –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–∏—Ä–æ–≤
	go cs.monitorPeers()

	return nil
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–µ—Ä–≤–∏—Å —á–∞—Ç–∞
func (cs *ChatService) Stop() error {
	cs.mutex.Lock()
	defer cs.mutex.Unlock()

	if !cs.isRunning {
		return nil
	}

	cs.isRunning = false
	close(cs.stopChan)

	// –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª—ã
	close(cs.messagesChan)
	close(cs.peersChan)

	log.Println("üõë ChatService –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
	return nil
}

// handleIncomingMessages –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —Å–µ—Ç–∏
func (cs *ChatService) handleIncomingMessages() {
	for {
		select {
		case rawMsg, ok := <-cs.coreController.Messages():
			if !ok {
				return // –ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç
			}
			cs.processIncomingMessage(rawMsg)

		case <-cs.stopChan:
			return
		}
	}
}

// processIncomingMessage –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–Ω–æ –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
func (cs *ChatService) processIncomingMessage(rawMsg core.RawMessage) {
	log.Printf("üì• –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç %s", rawMsg.SenderID.ShortString())

	// –î–µ–∫–æ–¥–∏—Ä—É–µ–º Protobuf —Å–æ–æ–±—â–µ–Ω–∏–µ
	envelope := &protocol.Envelope{}
	if err := proto.Unmarshal(rawMsg.Data, envelope); err != nil {
		log.Printf("‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è: %v", err)
		return
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞
	if envelope.GetContent() == nil {
		log.Printf("‚ö†Ô∏è –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –æ—Ç %s", rawMsg.SenderID.ShortString())
		return
	}

	content := envelope.GetContent()
	if content.GetText() == nil {
		log.Printf("‚ö†Ô∏è –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ —Ç–µ–∫—Å—Ç–∞ –æ—Ç %s", rawMsg.SenderID.ShortString())
		return
	}

	textMsg := content.GetText()

	// –°–æ–∑–¥–∞–µ–º ChatMessage –¥–ª—è UI
	chatMsg := ChatMessage{
		ID:          envelope.MessageId,
		Text:        textMsg.Body,
		SenderID:    envelope.SenderId,
		SenderName:  cs.getPeerName(envelope.SenderId),
		Timestamp:   time.Unix(envelope.TimestampUnix, 0),
		ChatType:    envelope.ChatType.String(),
		RecipientID: envelope.ChatId,
		IsOutgoing:  false,
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
	if err := cs.saveMessageToStorage(envelope, rawMsg.SenderID); err != nil {
		log.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –ë–î: %v", err)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª –¥–ª—è UI
	select {
	case cs.messagesChan <- chatMsg:
		log.Printf("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ UI: %s", chatMsg.Text[:min(len(chatMsg.Text), 50)])
	default:
		log.Printf("‚ö†Ô∏è –ö–∞–Ω–∞–ª UI –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω, —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ")
	}
}

// saveMessageToStorage —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
func (cs *ChatService) saveMessageToStorage(envelope *protocol.Envelope, senderID peer.ID) error {
	// –°–æ–∑–¥–∞–µ–º StoredMessage –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
	chatMsg := &storage.StoredMessage{
		ID:          envelope.MessageId,
		Text:        envelope.GetContent().GetText().Body,
		Timestamp:   time.Unix(envelope.TimestampUnix, 0),
		SenderID:    envelope.SenderId,
		ChatType:    envelope.ChatType.String(),
		RecipientID: envelope.ChatId,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
	return cs.messageRepository.Save(chatMsg)
}

// Send –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
func (cs *ChatService) Send(text string, chatType string, recipientID string) error {
	cs.mutex.RLock()
	if !cs.isRunning {
		cs.mutex.RUnlock()
		return fmt.Errorf("—Å–µ—Ä–≤–∏—Å —á–∞—Ç–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω")
	}
	cs.mutex.RUnlock()

	// –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —Å–æ–æ–±—â–µ–Ω–∏—è
	messageID := uuid.New().String()

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —á–∞—Ç–∞
	var chatTypeEnum protocol.Envelope_ChatType
	switch chatType {
	case "private":
		chatTypeEnum = protocol.Envelope_PRIVATE
	case "group":
		chatTypeEnum = protocol.Envelope_GROUP
	default:
		chatTypeEnum = protocol.Envelope_PRIVATE
	}

	// –°–æ–∑–¥–∞–µ–º Envelope —Å–æ–æ–±—â–µ–Ω–∏–µ
	envelope := &protocol.Envelope{
		MessageId:     messageID,
		SenderId:      cs.coreController.GetMyID(),
		TimestampUnix: time.Now().Unix(),
		ChatType:      chatTypeEnum,
		ChatId:        recipientID,
		Payload: &protocol.Envelope_Content{
			Content: &protocol.Content{
				Type: &protocol.Content_Text{
					Text: &protocol.TextMessage{
						Body: text,
					},
				},
			},
		},
	}

	// –ö–æ–¥–∏—Ä—É–µ–º –≤ Protobuf
	data, err := proto.Marshal(envelope)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è: %w", err)
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Å–µ—Ç—å
	if err := cs.coreController.Broadcast(data); err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —Å–µ—Ç—å: %w", err)
	}

	// –°–æ–∑–¥–∞–µ–º ChatMessage –¥–ª—è UI
	chatMsg := ChatMessage{
		ID:          messageID,
		Text:        text,
		SenderID:    cs.coreController.GetMyID(),
		SenderName:  "–í—ã",
		Timestamp:   time.Now(),
		ChatType:    chatType,
		RecipientID: recipientID,
		IsOutgoing:  true,
	}

	// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ –∫–∞–Ω–∞–ª –¥–ª—è UI
	select {
	case cs.messagesChan <- chatMsg:
		log.Printf("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: %s", text[:min(len(text), 50)])
	default:
		log.Printf("‚ö†Ô∏è –ö–∞–Ω–∞–ª UI –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω, –∏—Å—Ö–æ–¥—è—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ")
	}

	return nil
}

// GetMessages –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–Ω–∞–ª –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
func (cs *ChatService) GetMessages() <-chan ChatMessage {
	return cs.messagesChan
}

// GetPeers –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–Ω–∞–ª –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–∏—Ä–æ–≤
func (cs *ChatService) GetPeers() <-chan []peer.ID {
	return cs.peersChan
}

// monitorPeers –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Å–ø–∏—Å–∫–µ –ø–∏—Ä–æ–≤
func (cs *ChatService) monitorPeers() {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			peers := cs.coreController.GetPeers()
			select {
			case cs.peersChan <- peers:
				// –ü–∏—Ä—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ –∫–∞–Ω–∞–ª
			default:
				// –ö–∞–Ω–∞–ª –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
			}

		case <-cs.stopChan:
			return
		}
	}
}

// getPeerName –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–º—è –ø–∏—Ä–∞ (–Ω–∏–∫–Ω–µ–π–º –∏–ª–∏ PeerID)
func (cs *ChatService) getPeerName(peerID string) string {
	// TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ –Ω–∏–∫–Ω–µ–π–º–∞ –∏–∑ ContactRepository
	// –ü–æ–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ—Ä–æ—Ç–∫–∏–π PeerID
	if len(peerID) > 8 {
		return peerID[:8] + "..."
	}
	return peerID
}

// GetHistory –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π
func (cs *ChatService) GetHistory(limit int) ([]ChatMessage, error) {
	storedMessages, err := cs.messageRepository.GetHistory(limit)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏: %w", err)
	}

	// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º StoredMessage –≤ ChatMessage
	var chatMessages []ChatMessage
	for _, stored := range storedMessages {
		chatMsg := ChatMessage{
			ID:          stored.ID,
			Text:        stored.Text,
			SenderID:    stored.SenderID,
			SenderName:  cs.getPeerName(stored.SenderID),
			Timestamp:   stored.Timestamp,
			ChatType:    stored.ChatType,
			RecipientID: stored.RecipientID,
			IsOutgoing:  stored.SenderID == cs.coreController.GetMyID(),
		}
		chatMessages = append(chatMessages, chatMsg)
	}

	return chatMessages, nil
}

// min –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑ –¥–≤—É—Ö —á–∏—Å–µ–ª
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
